import {
  __commonJS
} from "./chunk-HM4MQYWN.js";

// node_modules/get-orientation/browser.js
var require_browser = __commonJS({
  "node_modules/get-orientation/browser.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.getOrientation = {}));
    })(exports, function(exports2) {
      "use strict";
      function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : new P(function(resolve2) {
              resolve2(result.value);
            }).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      (function(Orientation) {
        Orientation[Orientation["TOP_LEFT"] = 1] = "TOP_LEFT";
        Orientation[Orientation["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        Orientation[Orientation["BOTTOM_RIGHT"] = 3] = "BOTTOM_RIGHT";
        Orientation[Orientation["BOTTOM_LEFT"] = 4] = "BOTTOM_LEFT";
        Orientation[Orientation["LEFT_TOP"] = 5] = "LEFT_TOP";
        Orientation[Orientation["RIGHT_TOP"] = 6] = "RIGHT_TOP";
        Orientation[Orientation["RIGHT_BOTTOM"] = 7] = "RIGHT_BOTTOM";
        Orientation[Orientation["LEFT_BOTTOM"] = 8] = "LEFT_BOTTOM";
      })(exports2.Orientation || (exports2.Orientation = {}));
      const fileReaderMap = /* @__PURE__ */ new WeakMap();
      function getOrientation(input) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!(input instanceof ArrayBuffer || input instanceof Blob)) {
            throw new TypeError("Unexpected input type");
          }
          let offset = 0;
          const totalBytes = getSize(input);
          {
            const bufSignature = yield readBytes(input, offset, 4);
            offset += bufSignature.byteLength;
            const signature = new DataView(bufSignature);
            const head = signature.getUint16(0);
            const tail = signature.getUint16(2);
            if (head === 65496) {
              let bufMarker = bufSignature.slice(2);
              do {
                const marker = new DataView(bufMarker).getUint16(0);
                if (marker === 65505) {
                  const bufSegmentHead = yield readBytes(input, offset, 8);
                  const segmentHead = new DataView(bufSegmentHead);
                  const isEXIF = segmentHead.getUint16(2) === 17784 && segmentHead.getUint16(4) === 26982 && segmentHead.getUint16(6) === 0;
                  if (isEXIF) {
                    offset += bufSegmentHead.byteLength;
                    break;
                  } else {
                    const segmentSize = segmentHead.getUint16(0);
                    offset += segmentSize;
                  }
                } else if (65504 <= marker && marker <= 65519) {
                  const bufSegmentSize = yield readBytes(input, offset, 2);
                  offset += bufSegmentSize.byteLength;
                  const segmentSize = new DataView(bufSegmentSize).getUint16(0);
                  const remainingBytes = segmentSize - 2;
                  offset += remainingBytes;
                } else {
                  return exports2.Orientation.TOP_LEFT;
                }
                bufMarker = yield readBytes(input, offset, 2);
                offset += bufMarker.byteLength;
              } while (offset < totalBytes);
            } else if (head === 18761 && tail === 10752 || head === 19789 && tail === 42) {
              offset = 0;
            } else {
              return exports2.Orientation.TOP_LEFT;
            }
          }
          const bufTIFFHeader = yield readBytes(input, offset, 8);
          const tiffHeader = new DataView(bufTIFFHeader);
          const isLittleEndian = tiffHeader.getUint16(0) === 18761;
          const ifdOffset = tiffHeader.getUint32(4, isLittleEndian);
          offset += ifdOffset;
          const bufFieldCount = yield readBytes(input, offset, 2);
          offset += bufFieldCount.byteLength;
          let fieldCount = new DataView(bufFieldCount).getUint16(0, isLittleEndian);
          while (fieldCount-- > 0) {
            const bufField = yield readBytes(input, offset, 12);
            offset += bufField.byteLength;
            const field = new DataView(bufField);
            const tagId = field.getUint16(0, isLittleEndian);
            if (tagId === 274) {
              const value = new DataView(bufField.slice(8, 12)).getUint16(0, isLittleEndian);
              if (1 <= value && value <= 8) {
                return value;
              } else {
                throw new Error("Unexpected Orientation Value");
              }
            }
          }
          return exports2.Orientation.TOP_LEFT;
        });
      }
      function readBytes(input, offset, size) {
        if (input instanceof Blob) {
          return new Promise((resolve, reject) => {
            let reader = fileReaderMap.get(input);
            if (!reader) {
              reader = new FileReader();
              fileReaderMap.set(input, reader);
            }
            reader.onerror = (e) => {
              reader.onerror = null;
              reader.onload = null;
              reject(e);
            };
            reader.onload = () => {
              reader.onerror = null;
              reader.onload = null;
              resolve(reader.result);
            };
            reader.readAsArrayBuffer(input.slice(offset, offset + size));
          });
        }
        return Promise.resolve(input.slice(offset, offset + size));
      }
      function getSize(input) {
        return input instanceof Blob ? input.size : input.byteLength;
      }
      exports2.getOrientation = getOrientation;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
export default require_browser();
/*! Bundled license information:

get-orientation/browser.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation. All rights reserved.
      Licensed under the Apache License, Version 2.0 (the "License"); you may not use
      this file except in compliance with the License. You may obtain a copy of the
      License at http://www.apache.org/licenses/LICENSE-2.0
  
      THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
      WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
      MERCHANTABLITY OR NON-INFRINGEMENT.
  
      See the Apache Version 2.0 License for specific language governing permissions
      and limitations under the License.
      ***************************************************************************** *)
*/
//# sourceMappingURL=get-orientation_browser.js.map
