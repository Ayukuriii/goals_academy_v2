{
  "version": 3,
  "sources": ["../../get-orientation/base.ts", "../../get-orientation/browser.ts"],
  "sourcesContent": ["export enum Orientation {\n  TOP_LEFT = 1,         // Horizontal (Default)\n  TOP_RIGHT = 2,        // Mirror Horizontal\n  BOTTOM_RIGHT  = 3,    // Rotate 180\n  BOTTOM_LEFT = 4,      // Mirror vertical\n  LEFT_TOP = 5,         // Mirror horizontal and rotate 270 CW\n  RIGHT_TOP = 6,        // Rotate 90 CW\n  RIGHT_BOTTOM = 7,     // Mirror horizontal and rotate 90 CW\n  LEFT_BOTTOM = 8,      // Rotate 270 CW\n}\n", "import { Orientation } from \"./base\";\n\nexport { Orientation };\n\nconst fileReaderMap = new WeakMap<Blob, FileReader>();\n\nexport async function getOrientation(input: ArrayBuffer | File | Blob) {\n  if (!(input instanceof ArrayBuffer || input instanceof Blob)) {\n    throw new TypeError(\"Unexpected input type\");\n  }\n\n  let offset = 0;\n  const totalBytes = getSize(input);\n\n  // Signature validation\n  {\n    const bufSignature = await readBytes(input, offset, 4);\n    offset += bufSignature.byteLength;\n\n    const signature = new DataView(bufSignature);\n    const head = signature.getUint16(0);\n    const tail = signature.getUint16(2);\n\n    // Check EXIF SOI first\n    if (head === 0xffd8) {\n      // This is EXIF structure. handle application markers\n      let bufMarker = bufSignature.slice(2);\n      do {\n        const marker = (new DataView(bufMarker)).getUint16(0);\n        if (marker === 0xffe1) { // APP1 Marker - EXIF, or Adobe XMP\n          // We must verify that marker segment to avoid conflict.\n          // Adobe XMP uses APP1 space too!\n          const bufSegmentHead = await readBytes(input, offset, 8);\n          const segmentHead = new DataView(bufSegmentHead);\n\n          const isEXIF = segmentHead.getUint16(2) === 0x4578\n            && segmentHead.getUint16(4) === 0x6966\n            && segmentHead.getUint16(6) === 0x0000;\n\n          if (isEXIF) {\n            offset += bufSegmentHead.byteLength;\n            break;\n          } else {\n            const segmentSize = segmentHead.getUint16(0);\n            offset += segmentSize;\n          }\n        } else if (0xffe0 <= marker && marker <= 0xffef) { // Other JPEG application markers\n          // e.g. APP0 Marker (JFIF), APP2 Marker (FlashFix Extension, ICC Color Profile), Photoshop IRB...\n          // @see http://www.ozhiker.com/electronics/pjmt/jpeg_info/app_segments.html\n\n          // Just skip. we don't need them\n          const bufSegmentSize = await readBytes(input, offset, 2);\n          offset += bufSegmentSize.byteLength;\n\n          const segmentSize = (new DataView(bufSegmentSize)).getUint16(0);\n          const remainingBytes = segmentSize - 2;\n          offset += remainingBytes;\n        } else { // If any other JPEG marker segment was found, skip entire bytes.\n          // Please refer Table B.1 â€“ Marker code assignments from\n          // https://www.w3.org/Graphics/JPEG/itu-t81.pdf\n          return Orientation.TOP_LEFT;\n        }\n\n        bufMarker = await readBytes(input, offset, 2);\n        offset += bufMarker.byteLength;\n      } while (offset < totalBytes);\n    } else if ((head === 0x4949 && tail === 0x2a00) || (head === 0x4d4d && tail === 0x002a)) {\n      // yeah this is TIFF header\n      // reset offset cursor.\n      offset = 0;\n    } else { // This stream is not a JPEG file. Skip.\n      return Orientation.TOP_LEFT;\n    }\n  }\n\n  const bufTIFFHeader = await readBytes(input, offset, 8);\n\n  const tiffHeader = new DataView(bufTIFFHeader);\n  const isLittleEndian = tiffHeader.getUint16(0) === 0x4949;\n  const ifdOffset = tiffHeader.getUint32(4, isLittleEndian);\n\n  // move cursor to IFD block\n  offset += ifdOffset;\n\n  const bufFieldCount = await readBytes(input, offset, 2);\n  offset += bufFieldCount.byteLength;\n\n  let fieldCount = (new DataView(bufFieldCount)).getUint16(0, isLittleEndian);\n  while (fieldCount-- > 0) {\n    const bufField = await readBytes(input, offset, 12);\n    offset += bufField.byteLength;\n    const field = new DataView(bufField);\n\n    const tagId = field.getUint16(0, isLittleEndian);\n    if (tagId === 0x112) { // Orientation Tag\n      const value = (new DataView(bufField.slice(8, 12))).getUint16(0, isLittleEndian);\n\n      if (1 <= value && value <= 8) {\n        return value as Orientation;\n      } else {\n        throw new Error(\"Unexpected Orientation Value\");\n      }\n    }\n  }\n\n  return Orientation.TOP_LEFT;\n}\n\nfunction readBytes(input: Blob | ArrayBuffer, offset: number, size: number): Promise<ArrayBuffer> {\n  if (input instanceof Blob) {\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n      let reader = fileReaderMap.get(input)!;\n\n      if (!reader) {\n        reader = new FileReader();\n        fileReaderMap.set(input, reader);\n      }\n\n      reader.onerror = (e) => {\n        reader.onerror = null;\n        reader.onload = null;\n        reject(e);\n      };\n\n      reader.onload = () => {\n        reader.onerror = null;\n        reader.onload = null;\n\n        resolve(reader.result as ArrayBuffer);\n      };\n\n      reader.readAsArrayBuffer(\n        input.slice(offset, offset + size),\n      );\n    });\n  }\n\n  return Promise.resolve(input.slice(offset, offset + size));\n}\n\nfunction getSize(input: Blob | ArrayBuffer) {\n  return input instanceof Blob ?\n    input.size :\n    input.byteLength;\n}\n"],
  "mappings": "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",
  "names": ["Orientation"]
}
